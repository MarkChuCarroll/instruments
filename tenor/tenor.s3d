//
// A short-scale tenor guitar for 3d printing.
//
//


// Some convenience constants for units.
let inch_mm = 25.4
let one_sixteenth_inch = 1.0 / 16.0 * inch_mm
let one_eighth_inch = 1.0 / 8.0 * inch_mm
let one_quarter_inch = one_eighth_inch * 2.0
let one_half_inch = one_eighth_inch * 4.0


// Constants for the proportions of the guitar.

// - For the body size:
//   - the body is roughly teardrop shaped, formed from two cylinders.
//     The smaller cylinder is 2/5ths the radius of the larger.
let body_large_cylinder_radius = 140.0
let body_thickness = 60.0
// Total body size is approximately 28 centimeters, or 11 inches.
// The bridge sits 4 inches down the body from the end of the neck.
let bridge_to_neck = 4.0 * inch_mm


// Neck sizing.
let scale_length = 18.0 * inch_mm
let trussrod_length = 362.0 // aka around 14 inches.
let trussrod_width = 6.0 // approx 1/4 inch
let trussrod_depth = 11.6 // approx 1/2 inch
let neck_length = scale_length - bridge_to_neck
let neck_width = 45.0


// General utility function that divides a solid in half
// along the y axis. This doesn't quite work yet.
fun half(shape: Solid): Solid {
   let bounds = shape->bounds()
   let xsize = bounds->max()->x() - bounds->min()->x()
   let ysize = bounds->max()->y() - bounds->min()->y()
   let zsize = bounds->max()->z() - bounds->min()->z()

   let cut = cuboid(xsize, ysize, zsize)->move(0.0, ysize/2.0, 0.0)
   shape - cut
}


// Create a hexagonal solid inscribed inside a circle.
fun hexagon(rad: Float, thickness: Float): Solid {
    let cs = 3.0^0.5 / 2.0

    let p1 = v3(rad, 0.0, 0.0)
    let p2 = v3(rad/2.0, rad * cs, 0.0)
    let p3 = v3(-rad/2.0, rad * cs, 0.0)
    let p4 = v3(-rad, 0.0, 0.0)
    let p5 = v3(-rad/2.0, -rad * cs, 0.0)
    let p6 = v3(rad/2.0, -rad * cs, 0.0)
    polygon([p1, p2, p3, p4, p5, p6])->extrude(v3(0.0, 0.0, thickness))
}

// Create a flat octagon with the given radius at the points.
fun oct(diam: Float): Polygon {
    let sqrt2 = 2.0 ^ (0.5)
    let r = diam / 2.0
    let rsqrt = r / sqrt2
    polygon([ v3(-rsqrt, rsqrt, 0.0), v3(-r, 0.0, 0.0),
        v3(-rsqrt, -rsqrt,0.0), v3(0.0, -r, 0.0),
        v3(rsqrt, -rsqrt, 0.0), v3(r, 0.0, 0.0),
        v3(rsqrt, rsqrt, 0.0), v3(0.0, r, 0.0)])
}

// Create a triangular wedge.
fun wedge(x: Float, y: Float, thickness: Float): Solid {
    let triangle = polygon([v3(0.0, 0.0, 0.0), v3(x, 0.0, 0.0),  v3(x,  y, 0.0)])
    triangle->extrude(v3(0.0, 0.0, thickness))
}


// The body of the guitar.
// The main body shape is formed from the hull of two cylinders.
//
// TODO:
// - add the tailpiece and the tail string support.
fun body(width: Float, thickness: Float): Solid {
    fun base_shape(width: Float, thickness: Float): Solid {
        (cylinder(thickness, width, width * 3.0 / 4.0)->scale(1.3, 1.0, 1.0) +
            cylinder(thickness, width/2.0, width/2.0)->move(width, 0.0, 0.0))->hull()
    }

    fun sound_hole(): Solid {
         cylinder(thickness, width/5.0, width/5.0)->scale(1.5, 1, 1.0)->move(width/3.0, -width/2.0 , -thickness/2.0)
    }


    fun bracing(brace_length: Float, brace_width: Float, brace_height: Float): Solid {
        let brace_slot = cuboid(brace_length, brace_width, brace_height)
        let long_brace = brace_slot->scale(1.0, 1.5, 1.5) - brace_slot
        let brace_cap =   wedge(brace_height*3, brace_height * 1.5, brace_width * 1.5)->rotate(-90, 180, 0)
        let left_cap = brace_cap->move(160, - brace_width/2.0 - 1, -brace_height*0.75)
        let right_cap = brace_cap->rotate(0, 0, 180)->move(-160, brace_width/2.0 + 1, -brace_height*0.75)
        let capped_xbrace = (long_brace + left_cap + right_cap)->move(0.0, 0.0, -30.0)

        let ybrace_block = cuboid(brace_width, width, brace_height)
        let ycap = wedge(brace_height, 2.0 * brace_height, brace_width)
        let ybrace = ybrace_block + ycap->rotate(-90.0, -90, 90)->move(-brace_width/2.0, width/2.0, brace_height/2.0) + ycap->rotate(-90, 90, 90)->move(brace_width/2.0, -width/2.0, brace_height/2.0)
        capped_xbrace + ybrace->move(-30, 0, -thickness/2.0)
   }

   fun tailpiece(width: Float, length: Float, thickness: Float): Solid {
       let pin = cylinder(thickness*2, 2.0, 2.0)
       let big = cuboid(1.0, width, thickness)
       let smaller = cuboid(1.0, width*0.8, thickness)->move(-length, 0.0, 0.0)
       let prism = (big + smaller)->hull()
            - pin->move(-length*0.85, width/2.0 * 0.2, 0.0)
            - pin->move(-length*0.85, width/2.0 * 0.6, 0.0)
            - pin->move(-length*0.85, -width/2.0 * 0.2, 0.0)
            - pin->move(-length*0.85, -width/2.0 * 0.6, 0.0)
            - pin->move(-length, width/2.0 * 0.2, 0.0)
            - pin->move(-length, width/2.0 * 0.6, 0.0)
            - pin->move(-length, -width/2.0 * 0.2, 0.0)
            - pin->move(-length, -width/2.0 * 0.6, 0.0)
    }


   let shape = base_shape(width, thickness)
   let compound = shape + shape->scale(0.9, 0.9, 1.0)->move(0.0, 0.0, -thickness*0.1)
   let inner = compound->scale(0.9, 0.9, 0.9)
   let outer = compound->hull()
   outer - inner - sound_hole() + bracing(260.0, 3.5, 10.0)->move(20.0, 0.0, 5.0)
         + tailpiece(neck_width, 40.0, 10.0)->move(-width - 10.0, 0.0, -20.0)
}


// and the neck of the guitar.
// TODO:
// - Split the neck, the same way we did the body, to make it small
//   enough to fit on mk4 printbed.
// - Add in the holes for the tuners.
// - Add a nut.
fun neck(scale: Float, offset: Float, width: Float): Solid {
    // The shape of the headstock is two overlapping octagons, plus a rectangular
    // extension to move the headstock away from the neck, plus a cylinder
    // to smooth the joint from the headstock to the neck.
    fun headstock(width: Float, thickness: Float): Solid {
        let o = oct(width*0.8)->extrude(v3(0.0, 0.0, thickness))
        let octagons = o + o->move(width * 0.70, 0.0, 0.0)
        let ext = cuboid(width, width /2.0, thickness * 0.8)
        let w = half(cylinder(width/4.0, width/4.0, width/4.0))->scale(1.0, 0.8, 1.0)->rotate(90.0, 90.0, 180.0)->move(-80.0, 0.0, 10.0)
        //wedge(width, width/8.0, width/2.0)->rotate(-90.0, 0.0, 190.0)->move(0.0, width/4.0, 0.0)
        octagons->move(-width/2.5, 0.0, 0.0) + (ext->move(-width/2.0, 0.0, thickness/2.0) + w)->hull()

    }


    fun heel(radius: Float, length: Float, thickness: Float): Solid {
        let shape: Solid = cylinder(1.0, radius, radius)->move(-radius, 0.0, 0.0) + cuboid(radius * 2.0, radius*2.0, 1.0)
        let offset = length / 4.0
        let result = (shape->scale(2.0, 1.5, 1.0)->move(-offset, 0.0, thickness) + shape)->hull()
        result->rotate(90.0, 0.0, -90.0)
    }


    fun trussrod_cutout(length: Float): Solid {
        let main_slot = cuboid(length*1.2, trussrod_depth + 1.0, trussrod_width)
        main_slot->rotate(90.0, 100.0, -90.0)
    }

     let length = scale - offset
     let main =  half(cylinder(length, width/2.0, width/2.0)->scale(1.0, 0.8, 1.0))
     let head =  headstock(width*2.0, width/3.0)->rotate(70.0, 0.0, 90.0)->move(0.0, -width + 2.0, length/2.0 + width * 1.8)
     let tail = heel(width/3.0, 50.0, 70.0)
     main + head + tail->move(0.0, -70.0, -length/2.0) - trussrod_cutout(length)->move(0.0, -trussrod_depth / 2.0, 50.0)
}


// generate an alignment peg for joining together split parts.
fun peg(diam: Float, len: Float): Solid {
    cylinder(len, diam/2.0, 0.3)->rotate(90.0, -90.0, 90.0)
}



// Take the guitar body, and slice out the right hand side, keeping the left,
// along a 45 degree line. This also adds alignment pegs and plates.
fun left_side(body: Solid): Solid {
    body  - cuboid(200.0, 400.0, 400.0)->move(100.0, 0.0, 0.0)->rotate(0.0, -45.0, 0.0) +

         peg(2.0, 4.0)->move(30.0, 0.0, 28.5) +
         peg(2.0, 4.0)->move(30.0, 95.0, 28.5) +
         peg(2.0, 4.0)->move(30.0, -95.0, 28.5) +
         peg(2.0, 4.0)->move(-29.0, 115.0, -30.0) +
         peg(2.0, 4.0)->move(-29.0, -115.0, -30.0) +
         cuboid(10.0, 150.0, 2.0)->move(-30.0, 0.0, -32.0)
}

// For attaching the neck, we'll be adding a screwblock. This generates the
// screw holes and nut-slots in the screwblock for the body.
// Nutslot positions:
// lower: 15mm above the bottom of the heel;
// upper:  40mm
fun nutslot(outer_size: Float, inner_size: Float, thickness: Float): Solid {
    hexagon(4.0, 2.0)->rotate(0.0, 90.0, 0.0) + cylinder(40.0, inner_size/2.0, inner_size/2.0)->rotate(0.0, 90.0, 0.0)
}

// Take the full guitar body, and subtract the left side, leaving us with
// the right hand side of the body, including slots for the alignment pegs
// from the left side.
fun right_side(b: Solid, left: Solid): Solid {
    b - left + cuboid(20.0, 100.0, 54.0)->move(178.0, 0.0, 0.0)
      - nutslot(4.0, 3.0, 2.0)->move(170.0, 0.0, -20.0)
      - nutslot(4.0, 3.0, 2.0)->move(170.0, 0.0, 5.0)
}

let full_body = body(body_large_cylinder_radius, body_thickness)
let necked_body = full_body -  neck(scale_length, bridge_to_neck, neck_width)->rotate(0.0, -90.0, 90.0)->move(380.0, 0.0, -50.0)
let left = left_side(necked_body)
let right = right_side(necked_body, left)






// We'll have a collection of products:
// - the two parts of the split body.
// - the two parts of the split neck.
// - a fully assembled guitar.
// - a bridge.
// - a nut.

produce("split-body") {
    left->move(0, 0, 300)
    right->move(0, 0, -300)
}

produce("neck") {
  neck(scale_length, bridge_to_neck, neck_width)
}

produce("assembled") {
    full_body + neck(scale_length, bridge_to_neck, neck_width)->rotate(0.0, -90.0, 90.0)->move(380.0, 0.0, -50.0)
}
